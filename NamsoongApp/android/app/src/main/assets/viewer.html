
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>PDF Viewer</title>
    
    <!-- 1. PDF.js Library (LOADING LOCALLY) -->
    <!-- Make sure you have these files in /android/app/src/main/assets/js/ -->
    <script src="./js/pdf.min.js"></script>
    <script src="./js/pdf.worker.min.js"></script>

    <!-- 2. FIX for INVISIBLE SELECTION: Load the official PDF.js CSS -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf_viewer.min.css"
    />

    <style>
      body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #F0F0F0; }
      #pdf-viewer {
        width: 100%;
        height: 100%;
        overflow: auto;
        -webkit-overflow-scrolling: touch;
      }
      #page-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px 0;
      }
      .page {
        position: relative;
        margin-bottom: 10px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      }
      /* We no longer need custom textLayer styles */
    </style>
  </head>
  <body>
    
    <div id="pdf-viewer">
      <div id="page-container"></div>
    </div>

    <script>
      // 3. Setup PDF.js (loading worker locally)
      const pdfjsLib = window["pdfjs-dist/build/pdf"];
      pdfjsLib.GlobalWorkerOptions.workerSrc = "./js/pdf.worker.min.js";
      
      const pageContainer = document.getElementById("page-container");
      const viewer = document.getElementById("pdf-viewer");
      let currentPdf = null;
      let currentPage = 1;
      let totalPages = 0;
      let renderedPages = new Set();

      // --- FIX for PIXELATION ---
      // We will render at 2x scale. It's crisper.
      const RENDER_SCALE = 2.0; 

      // 4. PostMessage bridge (unchanged)
      const postMessage = (message) => {
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage(JSON.stringify(message));
        }
      };

      // --- 5. FIX for 1.5 PAGE FREEZE: On-Demand Rendering ---
      const renderPage = async (pageNum) => {
        if (renderedPages.has(pageNum) || !currentPdf) return;
        renderedPages.add(pageNum);

        try {
          const page = await currentPdf.getPage(pageNum);
          const viewport = page.getViewport({ scale: RENDER_SCALE });

          const pageDiv = document.getElementById(`page-${pageNum}`);
          pageDiv.style.width = viewport.width + 'px';
          pageDiv.style.height = viewport.height + 'px';

          const canvas = document.createElement("canvas");
          canvas.width = viewport.width;
          canvas.height = viewport.height;
          
          const textLayerDiv = document.createElement("div");
          textLayerDiv.className = "textLayer";
          textLayerDiv.style.width = viewport.width + 'px';
          textLayerDiv.style.height = viewport.height + 'px';

          pageDiv.appendChild(canvas);
          pageDiv.appendChild(textLayerDiv);

          await page.render({
            canvasContext: canvas.getContext("2d"),
            viewport: viewport,
          }).promise;

          const textContent = await page.getTextContent();
          pdfjsLib.renderTextLayer({
            textContentSource: textContent,
            container: textLayerDiv,
            viewport: viewport,
            textDivs: [],
          });

        } catch (err) {
          console.error(`Failed to render page ${pageNum}`, err);
        }
      };

      // 6. This function checks which pages *should* be visible
      const queueRender = () => {
        if (!currentPdf) return;
        
        const viewerRect = viewer.getBoundingClientRect();
        let visiblePage = 1;

        for (let i = 1; i <= totalPages; i++) {
          const pageDiv = document.getElementById(`page-${i}`);
          if (!pageDiv) continue; 

          const pageRect = pageDiv.getBoundingClientRect();
          const isVisible = (pageRect.bottom >= viewerRect.top - 500) && 
                            (pageRect.top <= viewerRect.bottom + 500);

          if (isVisible) {
            if (pageRect.top <= viewerRect.top + 100) {
              visiblePage = i;
            }
            renderPage(i);
            renderPage(i + 1);
          }
        }
        
        if (visiblePage !== currentPage) {
          currentPage = visiblePage;
          postMessage({ type: 'PAGE_CHANGED', page: currentPage, totalPages: totalPages });
        }
      };

      // 7. Function to load the PDF (This is our entry point)
      const loadPdf = async (pdfUri) => {
        try {
          // We load from the URI (file://...)
          const loadingTask = pdfjsLib.getDocument(pdfUri); 
          currentPdf = await loadingTask.promise;
          totalPages = currentPdf.numPages;
          
          postMessage({ type: 'LOAD_COMPLETE', totalPages: totalPages });
          
          pageContainer.innerHTML = '';
          renderedPages.clear();

          // Create placeholders for all pages
          for (let i = 1; i <= totalPages; i++) {
            const pageDiv = document.createElement("div");
            pageDiv.id = `page-${i}`;
            const page = await currentPdf.getPage(i);
            const viewport = page.getViewport({ scale: RENDER_SCALE });
            pageDiv.style.width = viewport.width + 'px';
            pageDiv.style.height = viewport.height + 'px';
            pageDiv.className = "page";
            pageContainer.appendChild(pageDiv);
          }

          await renderPage(1);
          await renderPage(2);
          
          viewer.addEventListener('scroll', queueRender);
          
        } catch (err) {
          postMessage({ type: 'ERROR', message: err.message });
        }
      };

      // 8. Selection listener (Fixed)
      document.addEventListener("selectionchange", () => {
        const selection = window.getSelection();
        const selectedText = selection.toString().trim();
        
        if (selectedText.length > 0) {
          postMessage({ type: 'SELECTION_CHANGED', text: selectedText, page: currentPage });
        } else {
          postMessage({ type: 'SELECTION_CHANGED', text: '', page: currentPage });
        }
      });
      
      // 9. Message listener (Unchanged)
      document.addEventListener("message", (event) => {
        const data = JSON.parse(event.data);
        if (data.type === 'LOAD_PDF') {
          loadPdf(data.source.uri); // Expecting the file path
        }
      });
    </script>
  </body>
</html>